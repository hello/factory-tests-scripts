//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//********************************Main Function******************************************//

SetFinalizeFunction("Cleanup");
SetFailFunction("FailConfig");
SetAbortFunction("FailConfig");

$PassHtmlLocation1 = "C:\\Users\\windows\\Desktop\\onboardingFiles\\";
$PassHtmlLocation2 = "C:\\Users\\windows\\Desktop\\onboardingFiles\\";
//$PassHtmlLocation2 = "\\\\huafile01\\Hello_data\\test log\\Morpheus\\";
ConfigurableHtmlReportWriter_ConfigureLocations($PassHtmlLocation2,$PassHtmlLocation1);
$sense_id = "";
$wifi_name = "";
$wifi_connection_type = "";
$wifi_password = "";
$api_token = "";
$testName = "";
$firstRun = true;

$currentRun = 0;
$numberOfRuns = 100;
call Gb_Instrument_Init();//setupserial
while($currentRun < $numberOfRuns)
{
  $puppetConnected = false;
  $wifiConnected = false;
  $testRunName = StringCat("test_run_",$currentRun);
  SetTestName($testRunName);
  call kill_puppet();
  UpdateStatus("Killed Puppet");
  call power_on_sense();//turn on sense
  UpdateStatus("Booted sense");
  Sleep(4);
  call boot_top_board();
  UpdateStatus("Booted top board");
  Sleep(6);
  call factory_reset_sense();//to get into bt pairing
  UpdateStatus("Factory reset sense");
  Sleep(11);
  call power_cycle_sense();
  UpdateStatus("Power cycled sense");
  Sleep(4);
  call boot_top_board();
  UpdateStatus("Booted top board again");
  Sleep(8);
  call start_puppet();
  UpdateStatus("Started puppet");
  Sleep(4);
  UpdateStatus("Trying Puppet discover");
  call puppet_discover();
  UpdateStatus("Trying Puppet connect");
  call puppet_connect();
  Sleep(3);
  call puppet_scan_wifi();
  Sleep(3);
  call puppet_connect_wifi_hello();
  Sleep(3);
  UpdateStatus("Trying Puppet print wifi");
  call puppet_print_wifi();
  Sleep(3);
  call puppet_link_account();
  Sleep(3);
  call puppet_pair_pill();
  Sleep(2);
  call puppet_sense_factory_reset();
  Sleep(4);
  call puppet_reset_puppet();
  call power_off_sense();
  $currentRun = $currentRun + 1;
}

//~ adb shell am broadcast \
    //~ -p "is.hello.puppet" \
    //~ -a "is.hello.puppet.ACTION_DISCOVER" \
    //~ --es sense_id "<Sense device id>"

//~ wait-and-require-no-error

//~ adb shell am broadcast \
    //~ -p "is.hello.puppet" \
    //~ -a "is.hello.puppet.ACTION_CONNECT"

//~ wait-and-require-no-error

//~ adb shell am broadcast \
    //~ -p "is.hello.puppet" \
    //~ -a "is.hello.puppet.ACTION_PRINT_WIFI_NETWORK"

//~ wait-and-require-no-error

//~ adb shell am broadcast \
    //~ -p "is.hello.puppet" \
    //~ -a "is.hello.puppet.ACTION_SCAN_WIFI"

//~ wait-and-require-no-error

//~ adb shell am broadcast \
    //~ -p "is.hello.puppet" \
    //~ -a "is.hello.puppet.ACTION_CONNECT_WIFI" \
    //~ --es wifi_ssid "Hello" \
    //~ --es wifi_sec_type "SL_SCAN_SEC_TYPE_WPA2" \
    //~ --es wifi_password "[redacted]"

//~ wait-and-require-no-error

//~ adb shell am broadcast \
    //~ -p "is.hello.puppet" \
    //~ -a "is.hello.puppet.ACTION_LINK_ACCOUNT" \
    //~ --es access_token "<API access token>"

//~ wait-and-require-no-error

//~ adb shell am broadcast \
    //~ -p "is.hello.puppet" \
    //~ -a "is.hello.puppet.ACTION_PAIR_PILL" \
    //~ --es access_token "<API access token>"

//~ wait-and-require-no-error

//~ adb shell am broadcast \
    //~ -p "is.hello.puppet" \
    //~ -a "is.hello.puppet.ACTION_FACTORY_RESET"

//~ wait-and-require-no-error

//~ adb shell am broadcast \
    //~ -p "is.hello.puppet" \
    //~ -a "is.hello.puppet.ACTION_RESET"

//~ wait-and-require-no-error

////stop editing code here, unless you're making your own functions-BC
End ;
////////////////////////////////////////main Script///////////////////////////////////////////////////////

function puppet_discover()
{
  $sense_id = "A66B6BC4EB9CC237";
  call puppet_discover_general();
  return;
}

function puppet_discover_general()
{
  $testName = "discover_sense";
  $command = "adb shell am broadcast -p \"is.hello.puppet\" -a \"is.hello.puppet.ACTION_DISCOVER\"";
  $empty = "";
  $id_empty = StringComparison($sense_id,$empty,"==");//fucking ridiculous I know
  $id_not_empty = StringContains($id_empty,"False");
  UpdateStatus($id_not_empty);
  if ($id_not_empty)
  {
    $command = StringCat($command," --es sense_id \"");
    $command = StringCat($command,$sense_id);
    $command = StringCat($command,"\"");
  }
  
  UpdateStatus($command);
  call adb_go();
  return;
}

function puppet_connect()
{
  $testName = "connect_puppet";
  $command = "adb shell am broadcast -p \"is.hello.puppet\" -a \"is.hello.puppet.ACTION_CONNECT\"";
  UpdateStatus($command);
  
  call adb_go();
  $puppetConnected = $result;
  return;
}

function puppet_connect_no_check()
{
  $testName = "connect_puppet";
  $command = "shell am broadcast -p \"is.hello.puppet\" -a \"is.hello.puppet.ACTION_CONNECT\"";
  UpdateStatus($command);
  
  call adb_simple();
  return;
}

function puppet_print_wifi()
{
  if (!$puppetConnected)
  {
    return;
  }
  $testName = "print_wifi";
  $command = "adb shell am broadcast -p \"is.hello.puppet\" -a \"is.hello.puppet.ACTION_PRINT_WIFI_NETWORK\"";
  UpdateStatus($command);
  call adb_go();
  $wifiConnected = $result;
  return;
}

function puppet_scan_wifi()
{
  if (!$puppetConnected)
  {
    return;
  }
  $testName = "scan_wifi";
  $command = "adb shell am broadcast -p \"is.hello.puppet\" -a \"is.hello.puppet.ACTION_SCAN_WIFI\"";
  UpdateStatus($command);
  call adb_go();
  return;
}

function puppet_connect_wifi_hello()
{
  $wifi_name = "Hello";
  $wifi_connection_type = "SL_SCAN_SEC_TYPE_WPA2";
  $wifi_password = "godsavethequeen";
  call puppet_connect_wifi_general();
  return;
}

function puppet_connect_wifi_general()
{
  if (!$puppetConnected)
  {
    return;
  }
  $testName = "connect_wifi";
  //TODO: expand logic to not force a password if not WPA
  $wifiNameEmpty = StringComparison($wifi_name,"","==");
  $wifiNameEmptyBool = StringContains($wifiNameEmpty,"True");
  $wifiTypeEmpty = StringComparison($wifi_connection_type,"","==");
  $wifiTypeEmptyBool = StringContains($wifiTypeEmpty,"True");
  $wifiPassEmpty = StringComparison($wifi_password,"","==");
  $wifiPassEmptyBool = StringContains($wifiPassEmpty,"True");
  if ($wifiNameEmptyBool || $wifiTypeEmptyBool || $wifiPassEmptyBool)
  {
    RecordMeasurementPassFail("set_wifi_parameters","failed","bool",true,false);
    return;
    //fail
  }
  $command = "adb shell am broadcast -p \"is.hello.puppet\" -a \"is.hello.puppet.ACTION_CONNECT_WIFI\" --es wifi_ssid \"";
  $command = StringCat($command,$wifi_name);
  $command = StringCat($command,"\" --es wifi_sec_type \"");
  $command = StringCat($command,$wifi_connection_type);
  $command = StringCat($command,"\" --es wifi_password \"");
  $command = StringCat($command,$wifi_password);
  $command = StringCat($command,"\"");

  UpdateStatus($command);
  
  call adb_go();
  $wifiConnected = $result;
  return;
}

function puppet_link_account()
{
  $api_token = "2.32e50c783a784facb91d0d50a6b66d7e";
  call puppet_link_account_general();
  return;
}

function puppet_link_account_general()
{
  if (!$puppetConnected)
  {
    return;
  }
  if (!$wifiConnected)
  {
    return;
  }
  $testName = "link_account";
  $tokenEmpty = StringComparison($api_token,"","==");
  $tokenEmptyBool = StringContains($tokenEmpty,"True");
  if ($tokenEmptyBool)
  {
    RecordMeasurementPassFail("api_token_set","failed","bool",true,false);
    return;
    //fail
  }
  
  $command = "adb shell am broadcast -p \"is.hello.puppet\" -a \"is.hello.puppet.ACTION_LINK_ACCOUNT\" --es access_token \"";
  $command = StringCat($command,$api_token);
  $command = StringCat($command,"\"");

  UpdateStatus($command);
  call adb_go();
  
  return;
}

function puppet_pair_pill()
{
  $api_token = "2.32e50c783a784facb91d0d50a6b66d7e";
  call puppet_pair_pill_general();
  return;
}

function puppet_pair_pill_general()
{
  if (!$puppetConnected)
  {
    return;
  }
  if (!$wifiConnected)
  {
    return;
  }
  $testName = "pair_pill_send_command";
  $tokenEmpty = StringComparison($api_token,"","==");
  $tokenEmptyBool = StringContains($tokenEmpty,"True");
  if ($tokenEmptyBool)
  {
    RecordMeasurementPassFail("api_token_set","failed","bool",true,false);
    return;
    //fail
  }
  
  $command = "adb shell am broadcast -p \"is.hello.puppet\" -a \"is.hello.puppet.ACTION_PAIR_PILL\" --es access_token \"";
  $command = StringCat($command,$api_token);
  $command = StringCat($command,"\"");

  UpdateStatus($command);
  call adb_start();
  //shake the pill like a mofo
  $numShakesPerRound = 10;
  $currentShake = 0;
  $numRounds = 1;
  $currentRound = 0;
  $delayInShake = 50;//milliseconds
  $delayBetweenRounds = 2;//seconds
  while($currentRound < $numRounds)
  {
    while($currentShake < $numShakesPerRound)
    {
      $return= SerialSendMilliseconds($Userinterface_Handle, "#SK4$\r\n", "", 200); //waven
      SleepMilliseconds($delayInShake);
      $return= SerialSendMilliseconds($Userinterface_Handle, "#RK4$\r\n", "", 200); //waveoff
      SleepMilliseconds($delayInShake);
      $currentShake = $currentShake + 1;
    }
    Sleep($delayBetweenRounds);
    $currentRound = $currentRound + 1;
  }
  //hope it paired
  $testName = "pair_pill_read_response";
  call adb_end();
  
  return;
}

function puppet_sense_factory_reset()
{
  if (!$puppetConnected)
  {
    return;
  }
  $testName = "factory_reset_sense";
  $command = "adb shell am broadcast -p \"is.hello.puppet\" -a \"is.hello.puppet.ACTION_FACTORY_RESET\"";
  call adb_go();
  return;
}

function puppet_reset_puppet()
{
  $testName = "reset_puppet";
  $command = "adb shell am broadcast -p \"is.hello.puppet\" -a \"is.hello.puppet.ACTION_RESET\"";
  call adb_go();
  return;
}

function start_puppet()
{
  $testName = "start_puppet";
  $command = "shell am start -n \"is.hello.puppet/is.hello.puppet.ui.MainActivity\" -a android.intent.action.MAIN -c android.intent.category.LAUNCHER";
  call adb_simple();
  return;
}

function kill_puppet()
{
  $testName = "kill_puppet";
  $command = "shell am force-stop is.hello.puppet";
  call adb_simple();
  return;
}

function factory_reset_sense()
{
  $return2= SerialSendMilliseconds($uutHandle, "factory_reset\r\n" , "", 1000);
  RecordMeasurement("factory_reset_via_UART","complete","",true);
  return;
}

function power_cycle_sense()
{
  SerialSendMilliseconds($IT6322_Handle, "SYST:REM\n", "", 50);
  SerialSendMilliseconds($IT6322_Handle, "OUTP 0\n", "", 50);
  Sleep(3);
  SerialSendMilliseconds($IT6322_Handle, "SYST:REM\n", "", 50);       //IT6322B Initialize
  SerialSendMilliseconds($IT6322_Handle, "OUTP 1\n","",50);

  Sleep(1);
  //~ SerialSendMilliseconds($Userinterface_Handle, "#SK4$\r\n", "", 50);
  // Open the form.

  $return= SerialSendMilliseconds($Userinterface_Handle, "#IN1$\r\n", "OK", 1000);

  $return= SerialSendMilliseconds($Userinterface_Handle, "#IN1$\r\n", "OK", 1000);
  UpdateStatus($return);
  $Plugged = StringContains($return,"1");
  $Max_Retry=300;
  $Cont_Retry=0;
  while (($Plugged==false) && ($Cont_Retry < $Max_Retry))
  {
    $return= SerialSendMilliseconds($Userinterface_Handle, "#IN1$\r\n", "OK", 1000); 
    UpdateStatus($return);
    $Plugged = StringContains($return,"1");
    SleepMilliseconds(100);
    $Cont_Retry = $Cont_Retry + 1;
  }
  $return= SerialSendMilliseconds($Userinterface_Handle, "#RK0$\r\n", "", 50); //set to normal pin
  $return= SerialSendMilliseconds($Userinterface_Handle, "#SK1$\r\n", "", 50);  //sample switch on


  SerialSendMilliseconds($IT6322_Handle, "INST THI\r\n", "", 50);
  RecordMeasurement("power_cycle_sense","complete","",true);
  return;
}

function boot_top_board()
{
  $return2= SerialSendMilliseconds($uutHandle, "\r\nboot\r\n" , "", 1000);
  $return2= SerialSendMilliseconds($uutHandle, "\r\nboot\r\n" , "", 1000);
  RecordMeasurement("boot_top_board","complete","",true);
  return;
}

function adb_go()
{
  $TempStr="****************************" & $testName & "*********************************";
  UpdateStatus($TempStr);
  //don't be an asshole and use spaces
  $workingDir = "C:\\Users\\windows\\desktop\\";
  $logPath = "C:\\Users\\windows\\desktop\\logpath.txt";
  $pythonPath = "C:\\Users\\windows\\desktop\\sendAndReadADBCommand.py";
  $argumentString = StringCat($pythonPath," ");
  $argumentString = StringCat($argumentString,$logPath);
  $argumentString = StringCat($argumentString," ");
  $argumentString = StringCat($argumentString,$command);
  
  SystemCall($workingDir,"python",$argumentString,"TRUE","TRUE");
  
  
  $fileExists= CheckFileExists($logPath,"RETURNONLY");
  SleepMilliseconds(2000);
  if(!$fileExists)
  {
    RecordMeasurementPassFail("no_log_file","failed","bool",true,false);
    return;
  }
  $FileContents = FileReadAllText($logPath);
  UpdateStatus("//////////////////////////////////////////////////////////////////////////////////////////////");
  UpdateStatus($FileContents);
  UpdateStatus("//////////////////////////////////////////////////////////////////////////////////////////////");
  //////////////////////////////////////////////////////////////////////////////////////////////
  $passString="PASS";
  $failString="FAIL";

  $foundPass = StringContains($FileContents,$passString);
  $foundFail = StringContains($FileContents,$failString);
  $result = $foundPass && !$foundFail;
  RecordMeasurementPassFail($testName,$FileContents,"stringmatch",true,$result);
  return;
}

function adb_start()//needed when doing an operation on this level before json end is returned
{
  $TempStr="****************************" & $testName & "*********************************";
  UpdateStatus($TempStr);
  //don't be an asshole and use spaces
  $workingDir = "C:\\Users\\windows\\desktop\\";
  $logPath = "C:\\Users\\windows\\desktop\\logpath.txt";
  $pythonPath = "C:\\Users\\windows\\desktop\\sendADBCommand.py";
  $argumentString = StringCat($pythonPath," ");
  $argumentString = StringCat($argumentString,$logPath);
  $argumentString = StringCat($argumentString," ");
  $argumentString = StringCat($argumentString,$command);
  
  SystemCall($workingDir,"python",$argumentString,"TRUE","TRUE");
  
  
  $fileExists= CheckFileExists($logPath,"RETURNONLY");
  SleepMilliseconds(2000);
  if(!$fileExists)
  {
    RecordMeasurementPassFail("no_log_file","failed","bool",true,false);
    return;
  }
  $FileContents = FileReadAllText($logPath);
  UpdateStatus("//////////////////////////////////////////////////////////////////////////////////////////////");
  UpdateStatus($FileContents);
  UpdateStatus("//////////////////////////////////////////////////////////////////////////////////////////////");
  //////////////////////////////////////////////////////////////////////////////////////////////
  $passString="PASS";
  $failString="FAIL";

  $foundPass = StringContains($FileContents,$passString);
  $foundFail = StringContains($FileContents,$failString);
  $result = $foundPass && !$foundFail;
  RecordMeasurementPassFail($testName,$FileContents,"stringmatch",true,$result);
  return;
}

function adb_end()//used after adb_start
{
  $TempStr="****************************" & $testName & "*********************************";
  UpdateStatus($TempStr);
  //don't be an asshole and use spaces
  $workingDir = "C:\\Users\\windows\\desktop\\";
  $logPath = "C:\\Users\\windows\\desktop\\logpath.txt";
  $pythonPath = "C:\\Users\\windows\\desktop\\readADBCommand.py";
  $argumentString = StringCat($pythonPath," ");
  $argumentString = StringCat($argumentString,$logPath);
  $argumentString = StringCat($argumentString," ");
  $argumentString = StringCat($argumentString,$command);
  
  SystemCall($workingDir,"python",$argumentString,"TRUE","TRUE");
  
  
  $fileExists= CheckFileExists($logPath,"RETURNONLY");
  SleepMilliseconds(2000);
  if(!$fileExists)
  {
    RecordMeasurementPassFail("no_log_file","failed","bool",true,false);
    return;
  }
  $FileContents = FileReadAllText($logPath);
  UpdateStatus("//////////////////////////////////////////////////////////////////////////////////////////////");
  UpdateStatus($FileContents);
  UpdateStatus("//////////////////////////////////////////////////////////////////////////////////////////////");
  //////////////////////////////////////////////////////////////////////////////////////////////
  $passString="PASS";
  $failString="FAIL";

  $foundPass = StringContains($FileContents,$passString);
  $foundFail = StringContains($FileContents,$failString);
  $result = $foundPass && !$foundFail;
  RecordMeasurementPassFail($testName,$FileContents,"stringmatch",true,$result);
  return;
}

function adb_simple()//basically just send something simple, assume it works
{
  $TempStr="****************************" & $testName & "*********************************";
  UpdateStatus($TempStr);
  $workingDir = "C:\\Users\\windows\\desktop\\";
  
  SystemCall($workingDir,"adb",$command,"TRUE","TRUE");
  RecordMeasurementPassFail($testName,$command,"",true);
  
  return;
}
////////////////////////////////////////main Script///////////////////////////////////////////////////////

function Initial_Tests()
{
  SerialSendMilliseconds($Userinterface_Handle, "#SK6$\r\n", "", 150);//turn on fan
  $initialWaitTime = 200;
  $ranFinalGestureCount = false;
  $inFailTestSection = false;
  SetTestName("Initial_Tests")
  call Gb_Instrument_Init();
  call Lock_Door();
  return;
}

function power_off_sense()
{
  SerialSendMilliseconds($IT6322_Handle, "SYST:REM\n", "", 50);
  SerialSendMilliseconds($IT6322_Handle, "OUTP 0\n", "", 50);
  RecordMeasurement("power_off_sense","complete","",true);
  return;
}

function power_on_sense()
{
  UpdateStatus("**************************** Instrument_Init*********************************");
  //OperatorPrompt("Connect USB cable","OK");
  // power on
  Sleep(1);
  SerialSendMilliseconds($IT6322_Handle, "SYST:REM\n", "", 50);       //IT6322B Initialize
  SerialSendMilliseconds($IT6322_Handle, "OUTP 1\n","",50);

  Sleep(1);
  //~ SerialSendMilliseconds($Userinterface_Handle, "#SK4$\r\n", "", 50);
  // Open the form.
  $LoadWin = OperatorPromptNonBlocking("Place in UUT, plug in power", 200, 400);
  Sleep(1);

  $return= SerialSendMilliseconds($Userinterface_Handle, "#IN1$\r\n", "OK", 1000);

  $return= SerialSendMilliseconds($Userinterface_Handle, "#IN1$\r\n", "OK", 1000);
  UpdateStatus($return);
  $Plugged = StringContains($return,"1");
  Label UUT_CheckIn:
  $Max_Retry=1000;
  $Cont_Retry=0;
  while (($Plugged==false) && ($Cont_Retry < $Max_Retry))
  {
    $return= SerialSendMilliseconds($Userinterface_Handle, "#IN1$\r\n", "OK", 1000); //waveon
    UpdateStatus($return);
    $Plugged = StringContains($return,"1");
    SleepMilliseconds(100);
    $Cont_Retry = $Cont_Retry + 1;
  }

  OperatorPromptNonBlockingUpdateMessage($LoadWin, "Powerup UUT");
  Sleep(1);
  
  $return= SerialSendMilliseconds($Userinterface_Handle, "#RK0$\r\n", "", 50); //set to normal pin
  $return= SerialSendMilliseconds($Userinterface_Handle, "#SK1$\r\n", "", 50);  //sample switch on


  SerialSendMilliseconds($IT6322_Handle, "INST THI\n", "", 50);
  $CH3_return = SerialSendMilliseconds($IT6322_Handle,"MEAS:CURR?\n", "", 200);
  UpdateStatus($CH3_return);
  $CH3_return=$CH3_return*1000;
  UpdateStatus($CH3_return);

  $tmpMsg="Current draw: " + $CH3_return ;
  OperatorPromptNonBlockingUpdateMessage($LoadWin, $tmpMsg);

  $Max_Retry=1000;
  $Cont_Retry=0;
  while (($CH3_return < 150) && ($Cont_Retry < $Max_Retry))
  {
    $CH3_return = SerialSendMilliseconds($IT6322_Handle,"MEAS:CURR?\n", "", 200);
    UpdateStatus($CH3_return);
    $CH3_return=$CH3_return*1000;
    UpdateStatus($CH3_return);

    $tmpMsg="Please plug in UUT, Current draw < 0.1A : " + $CH3_return ;
    OperatorPromptNonBlockingUpdateMessage($LoadWin, $tmpMsg);

    SleepMilliseconds(100);
    $Cont_Retry = $Cont_Retry + 1;
  }

  if ($CH3_return < 0.1)
  {
    CloseForm($LoadWin);
    RecordMeasurementPassFail("sense_powerup","failed","failed",true,false);
  }

  $return= SerialSendMilliseconds($Userinterface_Handle, "#SK2$\r\n", "", 50); //indicator to operator to test

  $return= SerialSendMilliseconds($Userinterface_Handle, "#IN1$\r\n", "OK", 1000); //waveon
  UpdateStatus($return);
  $Plugged = StringContains($return,"1");
  SleepMilliseconds(100);
  if(!$Plugged)
  {
    OperatorPromptNonBlockingUpdateMessage($LoadWin, "USB 没插接好请重新接好!");
    goto UUT_CheckIn;
  }

  CloseForm($LoadWin);
  SerialSendMilliseconds($goldenUnitHandle, "loglevel 40\r\n", "", 100);
  SerialSendMilliseconds($goldenUnitHandle, "led\r\n", "", 100);//needed, probably because of golden firmware
  SerialSendMilliseconds($goldenUnitHandle, "led stop\r\n", "", 100);
  
  $wholeMessage="";
  $count=0;
  while($count < 20)
  {
    $newText= SerialSendMilliseconds($uutHandle, "", "", 100);
    UpdateStatus($newText);
    $wholeMessage = StringCat($wholeMessage, $newText);
    UpdateStatus("****************wholeMessage************\n");
    UpdateStatus($wholeMessage);
    UpdateStatus("****************************\n");
    //~ $Result = StringContains($return,"FreeRTOS");
    ($FrameFound,$ErrMsg,$Result_Value)=cRE_GeneralSingle($wholeMessage,"Top Board Version is .*\\r");//need to check for carriage return in case message is cutoff and don't get top board value
    
    if($FrameFound)
    {
      break;
    }
    SleepMilliseconds(500);
    $count=$count+1;
  }
  
  
  RecordMeasurementPassFail("sense_powerup","complete","passed",true,$FrameFound);
  
  if (!$firstRun)
  {
    return;
  }
  $firstRun = false;
    
  RecordMeasurementPassFail("boot_message_found",$wholeMessage,"bool",true,$FrameFound);//ugly text, but great info
  
    ///Version check
  ($FrameFound,$ErrMsg,$versionString)=cRE_GeneralSingle($wholeMessage,"FreeRTOS\\s.*?,");
  if ($FrameFound)
  {
    $subStringLength = StringLength($versionString);
    $subStringLength = Subtract($subStringLength,10);
    $versionString = StringSub($versionString,9,$subStringLength);
    RecordMeasurementPassFail("RTOS_version_check",$versionString,"bool",true,true);
  }
  
  ///Version hash
  ($FrameFound,$ErrMsg,$hashString)=cRE_GeneralSingle($wholeMessage,"FreeRTOS\\s.*?,\\s.*?,");
  if ($FrameFound)
  {
    $subStringLength = StringLength($hashString);
    $notMacLength = Add($subStringLength,2);
    $subStringLength = Subtract($subStringLength,9);
    $hashString = StringSub($hashString,$subStringLength,8);
    RecordMeasurementPassFail("version_hash_check",$hashString,"bool",true,true);
  }
  
  ///MAC address
  ($FrameFound,$ErrMsg,$macString)=cRE_GeneralSingle($wholeMessage,"FreeRTOS\\s.*");
  if ($FrameFound)
  {
    $macString = StringSub($macString,$notMacLength,1000);//large number to get to end of line
    ($FrameFound,$ErrMsg,$temp)=cRE_GeneralSingle($macString,"[0-9a-fA-F]+:[0-9a-fA-F]+:[0-9a-fA-F]+:[0-9a-fA-F]+:[0-9a-fA-F]+:[0-9a-fA-F]+");
    RecordMeasurementPassFail("mac_format_check",$macString,"bool",true,$FrameFound);
  }
  
  ///Top board ID
  ($FrameFound,$ErrMsg,$topID)=cRE_GeneralSingle($wholeMessage,"got\\sid\\sfrom\\stop\\s.*");
  if ($FrameFound)
  {
    $topID = StringSub($topID,16,1000);//large number to get to end of line
    ($FrameFound,$ErrMsg,$temp)=cRE_GeneralSingle($topID,"[0-9a-fA-F]+:[0-9a-fA-F]+:[0-9a-fA-F]+:[0-9a-fA-F]+:[0-9a-fA-F]+:[0-9a-fA-F]+:[0-9a-fA-F]+:[0-9a-fA-F]+");
    RecordMeasurementPassFail("top_id_format_check",$topID,"bool",true,$FrameFound);
  }
  
  //Top board Version
  ($FrameFound,$ErrMsg,$topVersionString)=cRE_GeneralSingle($wholeMessage,"Top\\sBoard\\sVersion\\sis\\s.*");
  if ($FrameFound)
  {
    $topVersionString = StringSub($topVersionString,21,1000);
    $topVersionString = StringTrim($topVersionString);
    RecordMeasurementPassFail("top_version_check",$topVersionString,"bool",true,true);
  }
  
  //FW Version
  ($FrameFound,$ErrMsg,$fwVersionString)=cRE_GeneralSingle($wholeMessage,"FW\\s.*");
  if ($FrameFound)
  {
    $fwVersionString = StringSub($fwVersionString,3,1000);
    $fwVersionString = StringTrim($fwVersionString);
    RecordMeasurementPassFail("fw_version_check",$fwVersionString,"bool",true,true);
    $newFW = true;
  }
  if (!$FrameFound)
  {
    $newFW = false;
    //RecordMeasurementPassFail("fw_version_string_not_found",$wholeMessage,"bool",true,false);//disabled unti FW upgraded
  }
  
  //PHY Version
  ($FrameFound,$ErrMsg,$phyVersionString)=cRE_GeneralSingle($wholeMessage,"PHY\\s.*");
  if ($FrameFound)
  {
    $phyVersionString = StringSub($phyVersionString,4,1000);
    $phyVersionString = StringTrim($phyVersionString);
    RecordMeasurementPassFail("phy_version_check",$phyVersionString,"bool",true,true);
  }
  
  //CHIP Version
  ($FrameFound,$ErrMsg,$chipVersionString)=cRE_GeneralSingle($wholeMessage,"CHIP\\s.*");
  if ($FrameFound)
  {
    $chipVersionString = StringSub($chipVersionString,4,1000);
    $chipVersionString = StringTrim($chipVersionString);
    RecordMeasurementPassFail("chip_version_check",$chipVersionString,"bool",true,true);
  }
  
  //NWP Version
  ($FrameFound,$ErrMsg,$nwpVersionString)=cRE_GeneralSingle($wholeMessage,"NWP\\s.*");
  if ($FrameFound)
  {
    $nwpVersionString = StringSub($nwpVersionString,3,1000);
    $nwpVersionString = StringTrim($nwpVersionString);
    RecordMeasurementPassFail("nwp_version_check",$nwpVersionString,"bool",true,true);
  }
  
  //ROM Version
  ($FrameFound,$ErrMsg,$romVersionString)=cRE_GeneralSingle($wholeMessage,"ROM\\s.*");
  if ($FrameFound)
  {
    $romVersionString = StringSub($romVersionString,3,1000);
    $romVersionString = StringTrim($romVersionString);
    RecordMeasurementPassFail("rom_version_check",$romVersionString,"bool",true,true);
  }
  
  return;
}

function Gb_Instrument_Init()
{
  
  $Sample_Serial = 8;
  //~ $UUT_Serial = 10;
  $UUT_Serial = 7;
  $uutHandle = SerialOpen($UUT_Serial,115200,8,"N",1);
  $goldenUnitHandle = SerialOpen($Sample_Serial,115200,8,"N",1);
  RecordMeasurement("setup_serial","complete","",true);

  return;
}

function Lock_Door()
{
  $return= SerialSendMilliseconds($Userinterface_Handle, "#SK3$\r\n", "", 50);  //lock door
  return;
}



function Prox_Values()
{
  $TestName="Prox";
  $TempStr="****************************" & $TestName & "*********************************";
  UpdateStatus($TempStr);
  SetTestName($TestName);
  $done = false;
  $maxTries = 3;
  $retryCount = 0;
  $LowerLimit = 0;//-1 means doesn't work
  $UpperLimit = 200000;

  while (!$done && $retryCount < $maxTries)
  {
    SerialSendMilliseconds($uutHandle, "gesture_count\r\n", "", 100);//clear count
    SleepMilliseconds(500);//let the count get cleared before triggering a wave? increased stability hopefully
    $return = SerialSendMilliseconds($Userinterface_Handle, "#SK4$\r\n", "", 200); //waveon
    SleepMilliseconds(500);
    if ($retryCount > 0)
    {
      SleepMilliseconds(500);
    }

    $Pattern = "(-?)\\d\\d\\d+";
    $serialCommand = "prox";
    $Next_Test = "prox_paddle_on";
    call serialSendAndReceivePattern_number_error();
    $return= SerialSendMilliseconds($Userinterface_Handle, "#RK4$\r\n", "", 200); //waveoff
    $Paddle_On = $Result_Value;

    $Next_Test = "prox_paddle_off";
    call serialSendAndReceivePattern_number_error();
    $Paddle_Off = $Result_Value;

    call Enable_Info_Logging();//gesture_count doesn't log to LOGF yet
    $Pattern = "(-?)\\d+\\stransition";
    $serialCommand = "gesture_count";
    $Next_Test = "one_wave_gesture_count";
    call serialSendAndReceivePattern_error();
    call Enable_Factory_Logging();//gesture_count doesn't log to LOGF yet
    $numGestures = StringReplace($Result_Value, " transition", "");
    if ($numGestures > 0)
    {
      $done = true;
    }
    $retryCount = $retryCount + 1;
  }
  if ($retryCount > 1)
  {
    RecordMeasurement("prox_attempts",$retryCount,"int",true);
  }
  RecordMeasurementWithLimits("prox_paddle_on",$Paddle_On,"ADC_counts",true,$LowerLimit,$UpperLimit,true);
  RecordMeasurementWithLimits("prox_paddle_off",$Paddle_Off,"ADC_counts",true,$LowerLimit,$UpperLimit,true);
  $Paddle_Delta = $Paddle_Off - $Paddle_On;
  RecordMeasurementWithLimits("prox_value_delta", $Paddle_Delta ,"ADC_counts",true,-10,100000,true);//get distribution, then set limits
  RecordMeasurementWithLimits("one_wave_gesture_count", $numGestures,"gestures",true,1,1,true);

  return;
}

function Prox_Values_Split()
{
  $TestName="Prox";
  $TempStr="****************************" & $TestName & "*********************************";
  UpdateStatus($TempStr);
  SetTestName($TestName);
  $done = false;
  $maxTries = 3;
  $retryCount = 0;
  $LowerLimit = 0;//-1 means doesn't work
  $UpperLimit = 200000;

  while (!$done && $retryCount < $maxTries)
  {
    SerialSendMilliseconds($uutHandle, "gesture_count\r\n", "", 100);//clear count
    SleepMilliseconds(200);//let the count get cleared before triggering a wave? increased stability hopefully
    $return = SerialSendMilliseconds($Userinterface_Handle, "#SK4$\r\n", "", 200); //waveon
    SleepMilliseconds(200);
    if ($retryCount > 0)
    {
      SleepMilliseconds(500);
    }

    $Pattern = "(-?)\\d\\d\\d+";
    $serialCommand = "prox";
    $Next_Test = "prox_paddle_on";
    call serialSendAndReceivePattern_number_error();
    $Paddle_On = $Result_Value;
    
    call Enable_Info_Logging();//gesture_count doesn't log to LOGF yet
    $Pattern = "(-?)\\d+\\stransition";
    $serialCommand = "gesture_count";
    $Next_Test = "paddle_on_gesture_count";
    call serialSendAndReceivePattern_error();
    call Enable_Factory_Logging();//gesture_count doesn't log to LOGF yet
    $numGestures = StringReplace($Result_Value, " transition", "");
    if ($numGestures > 0)
    {
      $done = true;
    }
    $paddleOnCount = $numGestures;
    
    $return= SerialSendMilliseconds($Userinterface_Handle, "#RK4$\r\n", "", 200); //waveoff

    SleepMilliseconds(200);
    $Pattern = "(-?)\\d\\d\\d+";
    $serialCommand = "prox";
    $Next_Test = "prox_paddle_off";
    call serialSendAndReceivePattern_number_error();
    $Paddle_Off = $Result_Value;

    call Enable_Info_Logging();//gesture_count doesn't log to LOGF yet
    $Pattern = "(-?)\\d+\\stransition";
    $serialCommand = "gesture_count";
    $Next_Test = "one_wave_gesture_count";
    call serialSendAndReceivePattern_error();
    call Enable_Factory_Logging();//gesture_count doesn't log to LOGF yet
    $numGestures = StringReplace($Result_Value, " transition", "");
    $paddleOffCount = $numGestures;
    $totalGestures = Add($paddleOffCount,$paddleOnCount);
    if ($numGestures > 0)
    {
      $done = true;
    }
    $retryCount = $retryCount + 1;
  }
  if ($retryCount > 1)
  {
    RecordMeasurement("prox_attempts",$retryCount,"int",true);
  }
  RecordMeasurementWithLimits("prox_paddle_on",$Paddle_On,"ADC_counts",true,$LowerLimit,$UpperLimit,true);
  RecordMeasurementWithLimits("prox_paddle_off",$Paddle_Off,"ADC_counts",true,$LowerLimit,$UpperLimit,true);
  $Paddle_Delta = $Paddle_Off - $Paddle_On;
  RecordMeasurementWithLimits("prox_value_delta", $Paddle_Delta ,"ADC_counts",true,-10,100000,true);//get distribution, then set limits
  RecordMeasurementWithLimits("paddle_on_gesture_count", $paddleOnCount,"gestures",true,0,1,true);
  RecordMeasurementWithLimits("paddle_off_gesture_count", $paddleOffCount,"gestures",true,0,1,true);
  RecordMeasurementWithLimits("total_gesture_count", $totalGestures,"gestures",true,1,2,true);

  return;
}

function Top_Board_Version_Check()
{
  $TestName="Top_Board_Version_Check";
  $TempStr="****************************" & $TestName & "*********************************";
  UpdateStatus($TempStr);
  SetTestName($TestName);
  $Current_Version = "0.7.6";

  $Pattern = "\\d+(\\.\\d+)+";
  $serialCommand = "^ ver";
  $Next_Test = "version_matches";
  call serialSendAndReceivePattern_error();

  $Top_Version_Correct = StringComparison($Result_Value,$Current_Version,"==");
  RecordMeasurementPassFail($Next_Test,$Result_Value,"bool",true,$Top_Version_Correct);
  return;
}

function Top_Board_ID_Value()
{
  $TestName="Top_Board_ID_Check";
  $TempStr="****************************" & $TestName & "*********************************";
  UpdateStatus($TempStr);
  SetTestName($TestName);

  $Pattern = "[A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9]</data>";
  $serialCommand = "^ id";
  $Next_Test = "id_value";
  call serialSendAndReceivePattern_error();

  $ID_value = StringReplace($Result_Value,"</data>","");
  RecordMeasurement($Next_Test,$ID_value,"string",true);
  return;
}

function Check_SD_Card()
{
  $TestName="Check_SD_Card";
  $TempStr="****************************" & $TestName & "*********************************";
  UpdateStatus($TempStr);
  SetTestName($TestName);


  $return2= SerialSendMilliseconds($uutHandle, "cd RINGTONE\r\n" , "", 1000);  //
  UpdateStatus("^^^^^^^^^^^^^^^^^^^^^^^^");
  UpdateStatus($return2);
  UpdateStatus("^^^^^^^^^^^^^^^^^^^^^^^^");
  SerialPurge($uutHandle);
  $return1= SerialSendMilliseconds($uutHandle, "ls\r\n", "", 100);  //
  UpdateStatus("^^^^^^^^^^^^^^^^^^^^^^^^");
  UpdateStatus($return1);
  UpdateStatus("^^^^^^^^^^^^^^^^^^^^^^^^");
  $return=$return1;

  $count=0;
  while($count < 50)
  {
    $return1= SerialSendMilliseconds($uutHandle, "", "", 300);  //

    UpdateStatus("^^^^^^^^^^^^^^^^^^^^^^^^");
    UpdateStatus($return1);
    UpdateStatus("^^^^^^^^^^^^^^^^^^^^^^^^");
    $return=$return+$return1;
    $Result = StringContains($return,"File(s)");

    if($Result )
    {
      break;
    }
    $count=$count+1;
  }

  $Result1 = StringContains($return,"tone.raw");
  $Result=$Result1 && $Result;
  $Result1 = StringContains($return,"STAR005.raw");
  $Result=$Result1 && $Result;
  $Result1 = StringContains($return,"STAR004.raw");
  $Result=$Result1 && $Result;
  $Result1 = StringContains($return,"STAR003.raw");
  $Result=$Result1 && $Result;
  $Result1 = StringContains($return,"STAR002.raw");
  $Result=$Result1 && $Result;
  $Result1 = StringContains($return,"STAR001.raw");
  $Result=$Result1 && $Result;
  $Result1 = StringContains($return,"pink.raw");
  $Result=$Result1 && $Result;
  $Result1 = StringContains($return,"ORG004.raw");
  $Result=$Result1 && $Result;
  $Result1 = StringContains($return,"ORG003.raw");
  $Result=$Result1 && $Result;
  $Result1 = StringContains($return,"ORG002.raw");
  $Result=$Result1 && $Result;
  $Result1 = StringContains($return,"ORG001.raw");
  $Result=$Result1 && $Result;
  $Result1 = StringContains($return,"NEW006.raw");
  $Result=$Result1 && $Result;
  $Result1 = StringContains($return,"NEW005.raw");
  $Result=$Result1 && $Result;
  $Result1 = StringContains($return,"NEW004.raw");
  $Result=$Result1 && $Result;
  $Result1 = StringContains($return,"NEW003.raw");
  $Result=$Result1 && $Result;
  $Result1 = StringContains($return,"NEW002.raw");
  $Result=$Result1 && $Result;
  $Result1 = StringContains($return,"NEW001.raw");
  $Result=$Result1 && $Result;
  $Result1 = StringContains($return,"DIG005.raw");
  $Result=$Result1 && $Result;
  $Result1 = StringContains($return,"DIG004.raw");
  $Result=$Result1 && $Result;
  $Result1 = StringContains($return,"DIG003.raw");
  $Result=$Result1 && $Result;
  $Result1 = StringContains($return,"DIG002.raw");
  $Result=$Result1 && $Result;
  $Result1 = StringContains($return,"DIG001.raw");
  $Result=$Result1 && $Result;


  RecordMeasurementPassFail("all_files_present",$Result,"bool",true,$Result);
  return;
}

function Speaker_Test()
{
  SerialSendMilliseconds($Userinterface_Handle, "#RK6$\r\n", "", 50);//turn off fan
  $TestName="Speaker";
  $TempStr="****************************" & $TestName & "*********************************";
  UpdateStatus($TempStr);
  SetTestName($TestName);
  $UpperLimit=15500;
  $LowerLimit=1000;
  call Start_Tone_UUT();
  SleepMilliseconds(2000);
  call Start_OCT_Golden();
  SleepMilliseconds(12000);
  call Get_OCT_Golden();
  call Stop_Tone_UUT();
  SerialSendMilliseconds($Userinterface_Handle, "#SK6$\r\n", "", 150);//turn on fan

  return;
}

function Mic_Test()
{
  SerialSendMilliseconds($Userinterface_Handle, "#RK6$\r\n", "", 50);//turn off fan
  $TestName="Mic";
  $TempStr="****************************" & $TestName & "*********************************";
  UpdateStatus($TempStr);
  SetTestName($TestName);
  $UpperLimit=15500;
  $LowerLimit=1000;
  call Start_Tone_Golden();
  SleepMilliseconds(2000);
  call Start_OCT_UUT();
  SleepMilliseconds(10000);
  call Get_OCT_UUT();
  call Stop_Tone_Golden();
  SerialSendMilliseconds($Userinterface_Handle, "#SK6$\r\n", "", 150);//turn on fan

  return;
}
function Start_Tone_UUT()
{
  $toneHandle = CopyVariable($uutHandle);
  call General_Start_Tone();
  return;
}

function Start_Tone_Golden()
{
  $toneHandle = CopyVariable($goldenUnitHandle);
  call General_Start_Tone();
  return;
}

function General_Start_Tone()
{
  $return= SerialSendMilliseconds($toneHandle, "p 55 48000  RINGTONE/tone.raw\r\n" , "", 100);
  return;
}

function Stop_Tone_UUT()
{
  $toneHandle = CopyVariable($uutHandle);
  call General_Stop_Tone();
  return;
}

function Stop_Tone_Golden()
{
  $toneHandle = CopyVariable($goldenUnitHandle);
  call General_Stop_Tone();
  return;
}

function General_Stop_Tone()
{
  $return= SerialSendMilliseconds($toneHandle, "s\r\n" , "", 100);
  return;
}

function Start_OCT_UUT()
{
  $octHandle = CopyVariable($uutHandle);
  call General_Start_OCT();
  return;
}

function Start_OCT_Golden()
{
  $octHandle = CopyVariable($goldenUnitHandle);
  call General_Start_OCT();
  return;
}

function General_Start_OCT()
{
  $return= SerialSendMilliseconds($octHandle, "oct\r\n", "", 100);
  return;
}

function Get_OCT_UUT()
{
  $octGetHandle = CopyVariable($uutHandle);
  $Next_Test = "get_oct_from_uut";
  call General_Get_OCT();
  return;
}

function Get_OCT_Golden()
{
  $octGetHandle = CopyVariable($goldenUnitHandle);
  $Next_Test = "get_oct_from_golden";
  call General_Get_OCT();
  return;
}

function General_Get_OCT()
{
  $Pattern = "(-?)\\d+";
  $serialCommand = "getoct";
  //$Next_Test set one level up
  $serialHandle = CopyVariable($octGetHandle);//gets reset to uut in serialSendAndReceivePattern
  call serialSendAndReceivePattern_number();
  RecordMeasurementWithLimits($Next_Test,$Result_Value,"",true,$LowerLimit,$UpperLimit,true);
  return;
}

function Antenna_1_rssi()
{
  $TestName="Wifi";
  $TempStr="****************************" & $TestName & "*********************************";
  UpdateStatus($TempStr);
  SetTestName($TestName);
  $maxTries = 3;
  $LowerLimit = -50;
  $UpperLimit = 0;
  $return= SerialSendMilliseconds($uutHandle, "antsel 1\r\n", "", 200);
  $Next_Test = "antenna1_rssi";
  call General_rssi();
  return;
}

function Antenna_2_rssi()
{
  $TestName="Wifi";
  $TempStr="****************************" & $TestName & "*********************************";
  UpdateStatus($TempStr);
  SetTestName($TestName);
  $maxTries = 3;
  $LowerLimit = -50;
  $UpperLimit = 0;
  $return= SerialSendMilliseconds($uutHandle, "antsel 2\r\n", "", 200);
  $Next_Test = "antenna2_rssi";
  call General_rssi();
  return;
}

function General_rssi()
{
  $retryCount = 0;
  $done = false;
  $Pattern = "TP-LINK_A1A2AC\\s(-?)\\d+";
  $serialCommand = "rssi";
  //$Next_Test set one level up
  while (!$done && $retryCount < $maxTries)
  {
    $initialWaitTime = 1500;
    call serialSendAndReceivePattern_general();
    $rssiValue = StringReplace($Result_Value, "TP-LINK_A1A2AC ", "");
    if (!$FrameFound)
    {
      $rssiValue = NaN;
      SleepMilliseconds(1000);
    }
    if ($FrameFound)
    {
      $done = true;
    }
    $retryCount = $retryCount + 1;
  }
  if ($retryCount > 1)
  {
    $tryName = StringCat($Next_Test,"_attempts");
    RecordMeasurement($tryName,$retryCount,"int",true);
  }
  RecordMeasurementWithLimits($Next_Test, $rssiValue, "dB", true, $LowerLimit, $UpperLimit, true);
  return;
}

function Middle_Board_Version_Check()
{
  $TestName="Middle_Board_Version_Check";
  $TempStr="****************************" & $TestName & "*********************************";
  UpdateStatus($TempStr);
  SetTestName($TestName);
  $Current_Version = "5b38a87c";

  $Pattern = ":\\s[A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9]";
  $serialCommand = "ver";
  $Next_Test = "mid_board_version";
  call serialSendAndReceivePattern_error();
  $Result_Value = StringReplace($Result_Value,": ","");
  $Top_Version_Correct = StringComparison($Result_Value,$Current_Version,"==");
  RecordMeasurementPassFail($Next_Test,$Result_Value,"string",true,$Top_Version_Correct);
  return;
}

function Light_Check()
{
  $TestName="Light";
  $TempStr="****************************" & $TestName & "*********************************";
  UpdateStatus($TempStr);
  SetTestName($TestName);
  $done = false;
  $maxTries = 3;
  $retryCount = 0;
  $upperLimitOff = 2000;
  $lowerLimitOff = 0;
  $upperLimitOn = 70000;
  $lowerLimitOn = 5000;
  $white = StringStartsWith($SerialNumber,"91000008W","TRUE");
  if ($white)
  {
    $lowerLimitOn = 17000;
  }

  while(!$done && $retryCount < $maxTries)
  {
    $done = true;
    $UpperLimit = $upperLimitOff;
    $LowerLimit = $lowerLimitOff;
    $Next_Test = "light_off_1";
    call General_Light_Test();
    call Compare_Result_To_Limits();
    $done = $done && $inLimits;
    $lightOff1 = $Result_Value;

    call LED_On_UUT();
    SleepMilliseconds(1500);
    if ($retryCount > 0)
    {
      SleepMilliseconds(1500);
    }

    $UpperLimit = $upperLimitOn;
    $LowerLimit = $lowerLimitOn;

    $Next_Test = "light_on_1";
    call General_Light_Test();
    call Compare_Result_To_Limits();
    $done = $done && $inLimits;
    $lightOn1 = $Result_Value;

    call LED_Off_UUT();
    SleepMilliseconds(1500);
    if ($retryCount > 0)
    {
      SleepMilliseconds(1500);
    }

    $UpperLimit = $upperLimitOff;
    $LowerLimit = $lowerLimitOff;
    $Next_Test = "light_off_2";
    call General_Light_Test();
    call Compare_Result_To_Limits();
    $done = $done && $inLimits;
    $lightOff2 = $Result_Value;

    $retryCount = $retryCount + 1;
  }
  if ($retryCount > 1)
  {
    RecordMeasurement("light_test_attempts",$retryCount,"int",true);
  }
  RecordMeasurementWithLimits("light_off_1", $lightOff1, "int", true, $lowerLimitOff, $upperLimitOff, true);
  RecordMeasurementWithLimits("light_on_1", $lightOn1, "int", true, $lowerLimitOn, $upperLimitOn, true);
  RecordMeasurementWithLimits("light_off_2", $lightOff2, "int", true, $lowerLimitOff, $upperLimitOff, true);
  return;
}

function Compare_Result_To_Limits()
{
  $inLimits = false;
  if ($Result_Value >= $LowerLimit && $Result_Value <= $UpperLimit)
  {
    $inLimits = true;
  }
  return;
}

function General_Light_Test()
{
  $Pattern = "(-?)\\d+";
  $serialCommand = "light";
  //$Next_Test set one level up
  call serialSendAndReceivePattern_number();
  return;

  return;
}

function Wifi_Connect()
{
  $TestName="Wifi";
  $TempStr="****************************" & $TestName & "*********************************";
  UpdateStatus($TempStr);
  SetTestName($TestName);

  call Wifi_Connect_General();
  RecordMeasurement("wifi_connect",$return,"string",true);
  return;
}

function Wifi_Connect_General()
{
  $return= SerialSendMilliseconds($uutHandle, "connect TP-LINK_A1A2AC key 0\r\n", "", 100);
  return;
}

function Wifi_Disconnect_Initial()
{
  $TestName="Wifi";
  $TempStr="****************************" & $TestName & "*********************************";
  UpdateStatus($TempStr);
  SetTestName($TestName);
  $Next_Test = "wifi_disconnect_initial";
  call Wifi_Disconnect_General();
  RecordMeasurement($Next_Test,$return,"string",true);
  return;
}

function Wifi_Disconnect_Final()
{
  $TestName="Wifi";
  $TempStr="****************************" & $TestName & "*********************************";
  UpdateStatus($TempStr);
  SetTestName($TestName);
  $Next_Test = "wifi_disconnect_final";
  call Wifi_Disconnect_General();
  RecordMeasurement($Next_Test,$return,"string",true);
  return;
}

function Wifi_Disconnect_General()
{
  $return= SerialSendMilliseconds($uutHandle, "disconnect\r\n", "", 100);
  return;
}

function Wifi_Connection_Check()
{
  $TestName="Wifi";
  $TempStr="****************************" & $TestName & "*********************************";
  UpdateStatus($TempStr);
  SetTestName($TestName);
  $maxTries = 3;
  $retryCount = 0;
  $done = false;

  $Pattern = "IP=\\d+\\.\\d+\\.\\d+\\.\\d+";
  $serialCommand = "status";
  $Next_Test = "wifi_connection_status";
  while (!$done && $retryCount < $maxTries)
  {
    call serialSendAndReceivePattern_error();
    $done = StringContains($Result_Value,"IP=192.168.1.");
    if (!$done)
    {
      call Wifi_Connect_General();
      SleepMilliseconds(2000);
    }
    $retryCount = $retryCount + 1;
  }
  RecordMeasurementPassFail($Next_Test,$Result_Value,"IP",true,$done);

  return;
}

function Wifi_Disconnection_Check_Initial()
{
  $TestName="Wifi";
  $TempStr="****************************" & $TestName & "*********************************";
  UpdateStatus($TempStr);
  SetTestName($TestName);
  $maxTries = 5;
  $retryCount = 0;
  $done = false;
  $Next_Test = "wifi_disconnection_status_initial";
  while (!$done && $retryCount < $maxTries)
  {
    call Wifi_Disconnection_Check_General();
    $done = $disconnected;
    $retryCount = $retryCount + 1;
    if (!$done)
    {
      call Wifi_Disconnect_General();
      SleepMilliseconds(2000);
    }
  }
  if ($retryCount > 1)
  {
    RecordMeasurement("disconnect_initial_tries",$retryCount,"",true);
  }
  RecordMeasurementPassFail($Next_Test,$Result_Value,"IP",true,$disconnected);
  return;
}

function Wifi_Disconnection_Check_Final()
{
  $TestName="Wifi";
  $TempStr="****************************" & $TestName & "*********************************";
  UpdateStatus($TempStr);
  SetTestName($TestName);
  $maxTries = 3;
  $retryCount = 0;
  $done = false;
  $Next_Test = "wifi_disconnection_status_final";
  while (!$done && $retryCount < $maxTries)
  {
    call Wifi_Disconnection_Check_General();
    $done = $disconnected;
    $retryCount = $retryCount + 1;
    if (!$done)
    {
      call Wifi_Disconnect_General();
      SleepMilliseconds(2000);
    }
  }
  if ($retryCount > 1)
  {
    RecordMeasurement("disconnect_final_tries",$retryCount,"",true);
  }
  RecordMeasurementPassFail($Next_Test,$Result_Value,"IP",true,$disconnected);
  return;
}

function Wifi_Disconnection_Check_General()
{
  $Pattern = "IP=\\d+\\.\\d+\\.\\d+\\.\\d+";
  $serialCommand = "status";
  //$Next test set one level up
  $initialWaitTime = 1500;
  call serialSendAndReceivePattern_general();
  $disconnected = StringContains($Result_Value,"IP=0.0.0.0");
  return;
}

function LED_On_UUT()
{
  $lightHandle = CopyVariable($uutHandle);
  call General_LED_On();
  return;
}

function General_LED_On()
{
  $return = SerialSendMilliseconds($lightHandle, "led\r\n", "", 500);
  return;
}

function LED_Off_UUT()
{
  $lightHandle = CopyVariable($uutHandle);
  call General_LED_Off();
  return;
}

function LED_Off_Golden()
{
  $lightHandle = CopyVariable($goldenUnitHandle);
  call General_LED_Off();
  return;
}

function General_LED_Off()
{
  $return= SerialSendMilliseconds($lightHandle, "led stop\r\n", "", 500);
  return;
}

function ZOGLAB_Measure()
{
  //SetTestName("ZOGLAB_Measure")
  UpdateStatus("****************************ZOGLAB_Measure*********************************");
  $receiveBuffer = SerialSend($ZOGLAB,"AT*ReadSensor:0\\r\\n","",5); //Read out the Humidity
  UpdateStatus("receiveBuffer...");
  UpdateStatus($receiveBuffer);
  $stationTemp = StringParse($receiveBuffer,"Temperature = ","C");
  $stationTemp = StringTrim($stationTemp);
  $stationHumid = StringParse($receiveBuffer,"Humidity = ","%");
  $stationHumid = StringTrim($stationHumid);
  UpdateStatus($stationTemp);
  UpdateStatus($stationHumid);
  $stationTemp = Add(0,$stationTemp);
  $stationHumid = Add(0,$stationHumid);
  UpdateStatus("****************************ZOGLAB_Measure*********************************");
  return;
}

function Temp_Humid()
{
  $TestName="Temp_Humid";
  $TempStr="****************************" & $TestName & "*********************************";
  UpdateStatus($TempStr);
  SetTestName($TestName);
  $maxRetry = 5;
  $Cont_Retry = 0;
  $Oh = 0;//will change after units measured
  $a = 17.625;//DO NOT CHANGE
  $b = 243.04;//DO NOT CHANGE
  $maxTempDelta = 5;
  $maxCalcHumidDelta = 5;
  ///////////////////////////////////////
  $deltaL = 0 - $maxCalcHumidDelta;
  $deltaH = $maxCalcHumidDelta;
  $done = false;
  $count = 0;
  while($count <= $maxRetry && !$done)
  {
    $count = $count + 1;

    //Get station temp and humidity
    call ZOGLAB_Measure();

    //Get station temp
    $Pattern = "(-?)\\d{3,5}";
    $serialCommand = "temp";
    $Next_Test = "get_morpheus_temp";//even though no test, used in case pattern not found
    call serialSendAndReceivePattern_number();
    $morpheusTemp = $Result_Value / 100;

    //Get station humidity
    $Pattern = "(-?)\\d{3,5}";
    $serialCommand = "humid";
    $Next_Test = "get_morpheus_humid";//even though no test, used in case pattern not found
    call serialSendAndReceivePattern_number();
    $morpheusHumid = $Result_Value / 100;

    //Check temperature accuracy
    $tempL = $stationTemp - $maxTempDelta;
    $tempH = $stationTemp + $maxTempDelta;
    if($morpheusTemp < $tempL || $morpheusTemp > $tempH)
    {
      //retry if temp out of spec
      continue;
    }

    $Td_a = $stationHumid/100;
    $Td_a = LogSpecifyBase($Td_a, 2.718281828);
    $Td_a = $Td_a + ($a * $stationTemp) / ($b + $stationTemp);
    $Td_a =  $b * $Td_a;
    UpdateStatus($Td_a);
    $Td_b = $stationHumid/100;
    $Td_b = LogSpecifyBase($Td_b, 2.718281828);
    $Td_b = $Td_b+(($a * $stationTemp) / ($b + $stationTemp));
    $Td_b =  $a - $Td_b;
    UpdateStatus($Td_b);
    $Td  = $Td_a / $Td_b;
    UpdateStatus("*************Td************");
    UpdateStatus($Td);//dewpoint of station
    UpdateStatus("***************************");

    $Hc_a = ($a * $Td) / ($b + $Td);
    $Hc_a = Power(2.718281828,$Hc_a);
    $Hc_a = 100 * $Hc_a;
    UpdateStatus($Hc_a);
    $Hc_b = ($a * $morpheusTemp) / ($b + $morpheusTemp);
    $Hc_b = Power(2.718281828,$Hc_b);
    UpdateStatus($Hc_b);
    $Hc =  $Hc_a / $Hc_b;
    UpdateStatus("*************Hc************");
    UpdateStatus($Hc);//calculation of humidity based on sense temp and station dewpoint
    UpdateStatus("***************************");

    $delta = $Hc - ($stationHumid - $Oh);//compare the values, with a delta offset, measured over large amount of units
    UpdateStatus("*************delta************");
    UpdateStatus($delta);
    UpdateStatus("****************************");

    if(($delta>=$deltaL) && ($delta<=$deltaH))
    {
      $done = true;
    }
  }
  if ($count > 1)
  {
    RecordMeasurement("temp_tries",$count,"",true);
  }
  RecordMeasurement("temp_station",$stationTemp,"C",true);
  RecordMeasurement("humid_station",$stationHumid,"%",true);
  RecordMeasurementWithLimits("temp_morpheus",$morpheusTemp,"C",true,$tempL,$tempH,true);
  RecordMeasurement("humid_morpheus",$morpheusHumid,"%",true);
  RecordMeasurement("humid_calc",$Hc,"%",true);
  RecordMeasurement("oh_offset",$Oh,"C",true);
  RecordMeasurementWithLimits("humidity_delta",$delta,"%",true,$deltaL,$deltaH,true);
  return;
}

function serialSendAndReceivePattern_general()
{
  $checkEnding = StringEndsWith($serialCommand, "\r\n", true);
  if (!$checkEnding)
  {
    $serialCommand = StringCat($serialCommand,"\r\n");
    UpdateStatus("Added line return");
  }
  $strippedCommand = StringReplace($serialCommand,"\r\n","");
  $currentAttempt = 0;
  $emptyTimeOut = 100;
  $Serial_Retry = 30;
  $currentReturn = SerialSendMilliseconds($serialHandle, $serialCommand, "", $initialWaitTime);
  $initialWaitTime = 200;
  $totalReturn = "";
  while($currentAttempt < $Serial_Retry)
  {
    $currentAttempt = $currentAttempt + 1;
    $currentReturn = StringReplace($currentReturn, $strippedCommand,"");
    $totalReturn=$totalReturn + $currentReturn;
    $attemptTitle = $strippedCommand + $currentAttempt;
    $header = StringCat("^^^^^^^^^^^",$attemptTitle);
    $header = StringCat($header,"^^^^^^^^^^^");
    UpdateStatus($header);
    UpdateStatus($totalReturn);
    UpdateStatus("^^^^^^^^^^^^^^^^^^^^^^^^");
    ($FrameFound,$ErrMsg,$Result_Value)=cRE_GeneralSingle($totalReturn,$Pattern);
    if($FrameFound)
    {
      UpdateStatus("Frame found");
      UpdateStatus($Result_Value);
      UpdateStatus("Thatwastheframe");
      $Result_Value = StringTrim($Result_Value);
      $serialHandle = CopyVariable($uutHandle);
      return;
    }
    UpdateStatus($Pattern);
    UpdateStatus("Frame not found");
    SleepMilliseconds(100);
    $currentReturn= SerialSendMilliseconds($serialHandle,"", "", $emptyTimeOut);
  }
  $serialHandle = CopyVariable($uutHandle);
  return;
}

function serialSendAndReceivePattern_number()
{
  call serialSendAndReceivePattern_general();
  if ($FrameFound)
  {
    $Result_Value = Add(0,$Result_Value);
  }
  if (!$FrameFound)
  {
    $Result_Value = NaN;
  }
  return;
}

function serialSendAndReceivePattern_number_error()
{
  call serialSendAndReceivePattern_general();
  if ($FrameFound)
  {
    $Result_Value = Add(0,$Result_Value);
  }
  if (!$FrameFound)
  {
    $Result_Value = NaN;
    $Test_Fail_Name = StringCat($Next_Test, "_pattern_not_found")
    RecordMeasurementPassFail($Test_Fail_Name,$Pattern,"bool",true,false);
  }
  return;
}

function serialSendAndReceivePattern_error()
{
  call serialSendAndReceivePattern_general();
  if (!$FrameFound)
  {
    $Test_Fail_Name = StringCat($Next_Test, "_pattern_not_found")
    RecordMeasurementPassFail($Test_Fail_Name,$Pattern,"bool",true,false);
  }
  return;
}

function Enable_Factory_Logging()
{
  SerialSendMilliseconds($uutHandle, "loglevel 40\r\n", "", 10);
  return;
}

function Enable_Info_Logging()
{
  SerialSendMilliseconds($uutHandle, "loglevel 1\r\n", "", 10);
  return;
}

function Dust_Sensor_Initial()
{
  call LED_Off_UUT();//required for dust reading
  $TestName="Dust";
  $TempStr="****************************" & $TestName & "*********************************";
  UpdateStatus($TempStr);
  SetTestName($TestName);
  $serialCommand = "dust 100";
  $Next_Test = "initial_dust";
  $Pattern = "(-?)\\d+";
  $initialWaitTime = 1000;
  call serialSendAndReceivePattern_number();

  RecordMeasurement($Next_Test, $Result_Value,"ADC_counts",true);
  return;
}

function Dust_Sensor_Final()
{
  call LED_Off_UUT();//required for dust reading
  $TestName="Dust";
  $TempStr="****************************" & $TestName & "*********************************";
  UpdateStatus($TempStr);
  SetTestName($TestName);
  $lowerLimit = 300;
  $upperLimit = 1500;
  $Pattern = "(-?)\\d+";
  $serialCommand = "dust 400";
  $Next_Test = "dust_calibration_value";
  $initialWaitTime = 5000;//dust sensor takes 4 secs with dust 400 command
  call serialSendAndReceivePattern_number_error();
  RecordMeasurementWithLimits($Next_Test, $Result_Value,"ADC Counts",true,$lowerLimit,$upperLimit,true);

  return;
}

function FailConfig()
{
  ConfigurableHtmlReportWriter_ConfigureLocations($PassHtmlLocation1,$PassHtmlLocation1);
  End;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
function Cleanup()
{
  UpdateStatus("****************************Cleanup*********************************");
  SerialSendMilliseconds($Userinterface_Handle, "#RK5$\r\n", "", 50);  //
  SerialSendMilliseconds($Userinterface_Handle, "#RK6$\r\n", "", 50);//turn off fan
  $return= SerialSendMilliseconds($Userinterface_Handle, "#RK2$\r\n", "", 50); //indicator reset
  $return= SerialSendMilliseconds($Userinterface_Handle, "#RK1$\r\n", "", 50);  //sample switch on
  $return= SerialSendMilliseconds($Userinterface_Handle, "#RK0$\r\n", "", 50); //uut switch on
  $return= SerialSendMilliseconds($Userinterface_Handle, "#RK3$\r\n", "", 50);  //unlock


  SerialClose($uutHandle);
  SerialClose($goldenUnitHandle);
  CloseForm($LoadWin);
  End;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
function GlobalCleanup()
{
  UpdateStatus("****************************GlobalCleanup*********************************");


  $return= SerialSendMilliseconds($Userinterface_Handle, "#RK1$\r\n", "", 50);
  $return= SerialSendMilliseconds($Userinterface_Handle, "#RK0$\r\n", "", 50);
    //~ $return= SerialSendMilliseconds($Userinterface_Handle, "#RK2$\r\n", "", 50);
  $return= SerialSendMilliseconds($Userinterface_Handle, "#RK9$\r\n", "", 50);
  SerialSendMilliseconds($Userinterface_Handle, "#RK6$\r\n", "", 50);//turn off fan
  SerialClose($Userinterface_Handle);
  SerialClose($goldenUnitHandle);
  SerialClose($ZOGLAB);

  $Userinterface_Serial = 2;
  $Userinterface_Handle = SerialOpen($Userinterface_Serial,19200,8,"N",1);
  $return= SerialSendMilliseconds($Userinterface_Handle, "#RKA$\r\n", "", 250);
    //~ SerialSendMilliseconds($Userinterface_Handle, "#SK4$\r\n", "", 50);
  SerialClose($Userinterface_Handle);
  SerialClose($goldenUnitHandle);

  SerialSendMilliseconds($IT6322_Handle, "SYST:REM\n", "", 50);
  SerialSendMilliseconds($IT6322_Handle, "OUTP 0\n", "", 50);
  SerialClose($IT6322_Handle);
  End ;
}
